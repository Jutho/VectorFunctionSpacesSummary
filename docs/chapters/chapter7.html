<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jutho Haegeman">
<meta name="dcterms.date" content="2023-11-22">

<title>Vector- en functieruimten – Samenvatting - Chapter 7 — Function spaces</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Vector- en functieruimten – Samenvatting</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#summary" id="toc-summary" class="nav-link active" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#not-covered-in-class" id="toc-not-covered-in-class" class="nav-link" data-scroll-target="#not-covered-in-class">Not covered in class</a></li>
  <li><a href="#important-concepts" id="toc-important-concepts" class="nav-link" data-scroll-target="#important-concepts">Important concepts</a></li>
  <li><a href="#lemmas-propositions-theorems" id="toc-lemmas-propositions-theorems" class="nav-link" data-scroll-target="#lemmas-propositions-theorems">Lemmas, propositions, theorems</a></li>
  <li><a href="#for-applications-exercises" id="toc-for-applications-exercises" class="nav-link" data-scroll-target="#for-applications-exercises">For applications / exercises</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Chapter 7 — Function spaces</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jutho Haegeman </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 22, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<section id="summary" class="level1">
<h1>Summary</h1>
<p>Chapter 7 discusses some of the consequences and issues related to working with functions spaces and infinite-dimensional Hilbert spaces more generally. Many of the results require proofs that are very technical and are beyond the scope of this course (even though they are included in the lecture notes for completeness). The goal is to get a certain amount of intuition about what it means to work with functions in <span class="math inline">\(L^2([a,b])\)</span> or <span class="math inline">\(L^2(\mathbb{R})\)</span> (the important Hilbert space for quantum mechanics). This chapter deals with both the question of constructing an orthogonal basis (sections 7.3 and 7.4). A general function can then be expanded with respect to this basis, and thus gives rise to a sequence of expansion coefficients, which themselves live in the Hilbert space <span class="math inline">\(\ell^2(\mathbb{N})\)</span> or <span class="math inline">\(\ell^2(\mathbb{Z})\)</span>. The final two sections discuss the different classes of operators that are relevant for such Hilbert spaces, and their properties, as well as adressing of several of the complications that arise, both with respect to their definition, the definition of the adjoint, and their spectral properties. Most of these issues are discussed in the context of differential operators and the interplay with boundary conditions, which is where they are most relevant in physics applications. The emphasis is on gaining intuition through these examples, rather than on the technical aspects of the general statements.</p>
</section>
<section id="not-covered-in-class" class="level1">
<h1>Not covered in class</h1>
<p>While all sections where touched upon in class, several sections in the lecture notes contain technical results and their proofs which we did not discuss and are beyond the scope of this course (in particular everything in 7.1, subsections 7.4.2 and 7.4.3, section 7.6.1). Subsection 7.3.6 (Gaussian quadrature) was only covered up to (and including) Theoreom 7.13.</p>
</section>
<section id="important-concepts" class="level1">
<h1>Important concepts</h1>
<ul>
<li><p>Function spaces can be given a proper norm and, for <span class="math inline">\(L^2\)</span>, an inner product. The non-trivial step involves `identifying’ functions that are equal almost everywhere, as one and the same (technically, working with equivalence classes of functions that are equal almost everywhere).</p></li>
<li><p>The function space <span class="math inline">\(L^2\)</span> has interesting dense subspaces such as smooth or continuous functions, which are the ones we typically deal with</p></li>
<li><p>Polynomials are dense (in Hilbert spaces where they are square integrable, either because of a finite interval or because of a proper weight function, or both) and can be turned into an orthogonal basis with a number of interesting properties (recurrence relation and structure of roots=zeros)</p></li>
<li><p>Trigonometric polynomials are dense = Fourier modes are complete and thus the expansion theorem (Chapter 5 applies); unitary transformation between square integrable functions on an interval, and square summable sequence of Fourier coefficients (Parseval); Fourier coefficients have a number of interesting properties (translation, modulation, scaling, convolutions, …); Fourier series converge faster for smooth functions and have slow convergence for functions with discontinuities (Gibbs phenomenon); relation with discrete Fourier transform</p></li>
<li><p>Unbounded operators are only defined on a subspace of the full Hilbert space = domain; the interesting class of operators are those for which that domain is still dense (=&gt; no vector is orthogonal to the domain).</p></li>
<li><p>Also the adjoint of an unbounded operator needs a domain, namely all <span class="math inline">\(w\)</span> for which we can make <span class="math inline">\(\langle w, \hat{A} v \rangle = \langle \hat{A}^\dagger w, v\rangle\)</span> work for all <span class="math inline">\(v\)</span> in the domain of <span class="math inline">\(\hat{A}\)</span>. For differential operators, this relates to choosing boundary conditions for <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span>.</p></li>
<li><p>Understanding the difference between being Hermitian/symmetric (<span class="math inline">\(\langle w, \hat{A} v \rangle = \langle A w,v\rangle\)</span> for all <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span> in domain of <span class="math inline">\(A\)</span>) and being self adjoint, again in the case of differential operators.</p></li>
<li><p>The spectrum of an operator <span class="math inline">\(\hat{A}\)</span> in an infinite-dimensionalHilbert space consists of three parts:</p>
<ul>
<li>The point spectrum: actual eigenvalues <span class="math inline">\(\lambda\)</span> with normalizable eigenvectors <span class="math inline">\(v\)</span>: <span class="math inline">\(\hat{A} v = \lambda v\)</span></li>
<li>The continuous spectrum: values <span class="math inline">\(\lambda\)</span> for which we can find approximate eigenvectors, but no exact eigenvectors that we can properly normalize; we can find <span class="math inline">\(v_\epsilon\)</span> such that <span class="math inline">\(\lVert \hat{A} v_\epsilon - \lambda v_\epsilon \rVert &lt; \epsilon\)</span> for all <span class="math inline">\(\epsilon&gt;0\)</span>, but the limit <span class="math inline">\(\epsilon \to 0\)</span> of <span class="math inline">\(v_\epsilon\)</span> is not well defined</li>
<li>The residual spectrum: very unintuitive and related to the fact that, on infinite-dimensional Hilbert spaces <span class="math inline">\(\nu(\hat{A})\)</span> (dimension of the kernel) and <span class="math inline">\(\nu(\hat{A}^\dagger)\)</span> do not need to be the same; the residual spectrum consists of values <span class="math inline">\(\lambda\)</span> for which no eigenvectors or approximate eigenvectors exist, but for which <span class="math inline">\(\overline{\lambda}\)</span> is in the point spectrum of <span class="math inline">\(\hat{A}^\dagger\)</span>.</li>
</ul></li>
<li><p>For a self adjoint operator, the residual spectrum is empty, the point spectrum is discrete and associated eigenvectors are orthonormal, and the point and continuous spectrum only contain real numbers.</p></li>
</ul>
</section>
<section id="lemmas-propositions-theorems" class="level1">
<h1>Lemmas, propositions, theorems</h1>
<p>Important active proofs:</p>
<ul>
<li>Proposition 7.8, 7.9, 7.10, 7.11: properties of orthogonal polynomials (Cristoffel-Darboux formula does not need to be known by heart)</li>
<li>Proposition 7.12 (numerical integration)</li>
<li>Proposition 7.13 (Gaussian quadrature)</li>
<li>Proposition 7.17, 7.19, 7.24, 7.27: properties of the Fourier coefficients: proving the relation that the Fourier coefficients satisfy is an easy calculation, which you should be able to actively do. You do not need to know the technical conditions under which these manipulations are allowed, and which requirements they impose on the function <span class="math inline">\(f\)</span> or the Fourier coefficients <span class="math inline">\((\widehat{f}_k)\)</span>.</li>
<li>Proposition 7.31: operators with a commutator that yield the identity cannot be both bounded</li>
</ul>
</section>
<section id="for-applications-exercises" class="level1">
<h1>For applications / exercises</h1>
<ul>
<li>Computing inner products and applying Gram-Schmidt to a small set of functions.</li>
<li>Deriving relations of specific families orthogonal polynomials, e.g.&nbsp;deriving orthonormalization relation or recurrence relation from generating function.</li>
<li>Computing simple Fourier coefficients using the elementary properties</li>
<li>Determining whether a (differential) operator with given boundary conditions is symmetric and/or self-adjoint</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>